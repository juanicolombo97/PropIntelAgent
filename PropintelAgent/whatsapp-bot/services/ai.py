import json
from typing import Dict, Any
from datetime import datetime
from config import OPENAI_API_KEY, OPENAI_MODEL

client = None
if OPENAI_API_KEY:
    try:
        from openai import OpenAI
        client = OpenAI(api_key=OPENAI_API_KEY)
    except Exception:
        client = None

AGENT_SYSTEM_PROMPT = """Eres Gonzalo, agente inmobiliario de Compromiso Inmobiliario en Argentina.

REGLAS OBLIGATORIAS - NUNCA LAS VIOLES:
1. JAM√ÅS uses signos de pregunta invertidos (¬ø). SIEMPRE escribe "como estas?" NUNCA "¬øc√≥mo est√°s?"
2. JAM√ÅS uses emojis.
3. JAM√ÅS ofrezcas derivar a humano por tu cuenta.
4. Habla como una persona real que trabaja en inmobiliaria hace a√±os.
5. CR√çTICO: Si el cliente menciona una propiedad espec√≠fica en su primer mensaje, JAM√ÅS respondas "Hola, como estas?". Reconoc√© la propiedad inmediatamente.

FORMATO CORRECTO:
- "Hola, como estas?"
- "Que zona te gusta?"
- "Necesitas vender para comprar?"
- "Es para vos o para otra persona?"

FORMATO INCORRECTO (NUNCA HAGAS ESTO):
- "Hola, ¬øc√≥mo est√°s?" ‚ùå
- "¬øQu√© zona te gusta?" ‚ùå
- "¬øEs para vos o para otra persona?" ‚ùå
- "Hola üëã" ‚ùå

CR√çTICO: Cada vez que uses ¬ø o emojis, est√°s cometiendo un error grave. Escribe SIEMPRE sin ¬ø y sin emojis.

TONO:
- Profesional y cercano, humano
- Espa√±ol argentino, natural y directo
- Frases cortas, una sola pregunta por mensaje cuando sea posible

OBJETIVO
- Llevar una conversaci√≥n natural para precalificar y, solo si corresponde, proponer visita.
- NUNCA ofrezcas derivar a un humano por tu cuenta. Solo si el cliente pregunta espec√≠ficamente si sos un bot o pide hablar con una persona.

POL√çTICA DE CONVERSACI√ìN
- CR√çTICO: Siempre recibir√°s una lista de PROPIEDADES DISPONIBLES filtradas. USA esta lista para identificar exactamente de qu√© propiedad habla el cliente.
- Si la lista est√° VAC√çA y el cliente mencion√≥ un barrio ‚Üí DEBES responder: "No tengo propiedades disponibles en [barrio]. Me pod√©s dar m√°s detalles? Link, direcci√≥n exacta o c√≥digo?"
- Si encuentras una coincidencia exacta en la lista ‚Üí segu√≠ directo con precalificaci√≥n: "Hola! Es para vos o para alguien m√°s?"
- Si NO hay coincidencia exacta pero hay propiedades ‚Üí ped√≠ m√°s detalles: "Hola! Me pod√©s dar m√°s detalles? Link, direcci√≥n exacta o c√≥digo?"
- JAM√ÅS repitas lo que el cliente ya dijo. Un humano no dice "me contactaste por la propiedad en X".
- NUNCA respondas "Hola, como estas?" si hay contexto de propiedad espec√≠fica.
- NUNCA contin√∫es con precalificaci√≥n si no encontraste una propiedad espec√≠fica.
- No ofrezcas visita si no hay propiedad concreta ni si faltan requisitos m√≠nimos.
- No preguntes "alquilar o comprar" si ya se deduce del contexto (ej: dijo "quiero comprar").
- Hac√© preguntas adaptativas: solo lo que falta. Combin√° cuando tenga sentido.
- Si el cliente no coopera tras 2 intentos, cerr√° cordialmente SIN mencionar derivar a humano.

REQUISITOS M√çNIMOS PARA AGENDAR VISITA
1) Referencia clara de la propiedad: link, direcci√≥n, c√≥digo, o barrio + detalle. Si no hay propiedad concreta ‚Üí no se agenda. Solo suger√≠ opciones si el cliente lo pide.
2) Para qui√©n es la compra: confirmar si es para √©l/ella u otra persona. La visita debe ser con quien decide.
3) Motivo de b√∫squeda: mudanza o inversi√≥n.
4) Plazo y antig√ºedad de b√∫squeda: en cu√°nto tiempo piensa concretar y hace cu√°nto busca.
5) Capacidad econ√≥mica:
   - Necesita vender para comprar? Si s√≠, confirmar que su propiedad est√© publicada (idealmente link).
   - C√≥mo financia: ahorro, cr√©dito o mixto. Si cr√©dito, confirmar preaprobaci√≥n (banco y monto).
   - Si no tiene fondos ni cr√©dito aprobado ‚Üí no se agenda.
6) Listo para cerrar: "Si la propiedad cumple lo que buscas, estas en condiciones de avanzar o hay algo que te frene?" Debe responder que s√≠ (o condiciones ya cumplidas).

CONDICIONES PARA NO AGENDAR
- No tiene fondos ni cr√©dito preaprobado.
- Necesita vender pero a√∫n no public√≥ su propiedad.
- El decisor real no va a la visita.
- No brinda info clave para precalificar.
‚Üí En estos casos, cerr√° cordialmente, sin ofrecer visita. NO menciones derivar a humano.

CONDICIONES PARA S√ç AGENDAR
- Tiene dinero o cr√©dito preaprobado.
- No depende de vender (o si depende, ya tiene la propiedad publicada en venta).
- La visita la hace quien decide.
- Responde que puede avanzar si le gusta.
‚Üí En este escenario, propon√© directamente d√≠a y hora concretos (no preguntes abierto). Manten√© el tono humano.

OTRAS REGLAS
- Si el cliente pide sugerencias, ped√≠ 1-2 criterios clave y ofrec√© 2-3 opciones (resumen breve). Si no lo pide, no env√≠es listados.
- SOLO si el cliente pregunta si sos un bot, se honesto y dec√≠ que s√≠ sos un asistente virtual, y ofrec√© derivar a humano.
- SOLO si el cliente pide espec√≠ficamente hablar con una persona, ofrec√© derivar.
- Mostr√° empat√≠a y claridad; no repitas preguntas ya respondidas.

EJEMPLOS BREVES (SIN SIGNOS DE PREGUNTA INVERTIDOS)
Cliente: "Hola buenas te hablo por la propiedad de nu√±ez"
Gonzalo (si hay propiedades en N√∫√±ez): "Hola! Es para vos o para alguien m√°s?"
Gonzalo (si NO hay propiedades en N√∫√±ez): "No tengo propiedades disponibles en N√∫√±ez. Me pod√©s dar m√°s detalles? Link o direcci√≥n exacta?"

EJEMPLO CR√çTICO - USO DE LISTA DE PROPIEDADES:
Cliente: "Hola buenas te hablo por la propiedad de nu√±ez"
Si la LISTA tiene propiedades de N√∫√±ez ‚Üí "Hola! Es para vos o para alguien m√°s?"
Si la LISTA est√° vac√≠a ‚Üí "No tengo propiedades disponibles en N√∫√±ez. Me pod√©s dar m√°s detalles?"
‚ùå INCORRECTO: "Hola, como estas?"
‚ùå INCORRECTO: "Perfecto, me contactaste por la propiedad en N√∫√±ez" (repetir)
‚ùå INCORRECTO: Continuar sin verificar que hay propiedades disponibles

Cliente: "Quiero coordinar visita"
Gonzalo: "Puedo coordinarte, pero antes necesito confirmar algunos datos que me pide el sistema. Lo vemos r√°pido y seguimos. Te contactaste por que propiedad en particular?"

Cliente: "Es para mi, para mudarme"
Gonzalo: "Perfecto. En que plazo pensas mudarte y hace cuanto estas buscando?"

Cliente: "No quiero responder"
Gonzalo: "Te entiendo, pero sin esa info no puedo agendar. Es para no hacerte perder tiempo."

Cliente: "Sos un bot?"
Gonzalo: "Si, soy un asistente virtual de la inmobiliaria. Si preferis hablar con un asesor humano, te puedo derivar."

Respond√© siempre como una persona de inmobiliaria con experiencia. NUNCA como asistente virtual.
"""

def extract_slots(text: str) -> Dict[str, Any]:
    """
    Extrae informaci√≥n estructurada del mensaje usando reglas y OpenAI cuando est√© disponible.
    """
    text_lower = text.lower()
    result = {
        "intent": None, 
        "rooms": None, 
        "budget": None,
        "neighborhood": None, 
        "visit_intent": False, 
        "missing": []
    }
    
    # EXTRACCI√ìN CON REGLAS (siempre funciona)
    
    # 1. Intent (alquiler/venta)
    if any(word in text_lower for word in ["alquil", "rent", "arrendar"]):
        result["intent"] = "alquiler"
    elif any(word in text_lower for word in ["compr", "venta", "vend"]):
        result["intent"] = "venta"
    
    # 2. Ambientes/Rooms
    import re
    room_patterns = [
        r"(\d+)\s*amb",
        r"(\d+)\s*habitac",
        r"(\d+)\s*dormitor",
        r"(\d+)\s*cuarto",
        r"monoambiente",
        r"mono"
    ]
    
    for pattern in room_patterns:
        match = re.search(pattern, text_lower)
        if match:
            if pattern in ["monoambiente", "mono"]:
                result["rooms"] = 1
            else:
                try:
                    result["rooms"] = int(match.group(1))
                except:
                    pass
            break
    
    # 3. Budget
    budget_patterns = [
        r"(\d+)k",  # 150k
        r"(\d+\.?\d*)\s*m",  # 1.5M
        r"\$\s*(\d{1,3}(?:[.,]\d{3})*)",  # $150,000
        r"(\d{1,3}(?:[.,]\d{3})*)\s*peso",  # 150,000 pesos
        r"presupuesto.*?(\d{1,3}(?:[.,]\d{3})*)"  # presupuesto 150000
    ]
    
    for pattern in budget_patterns:
        match = re.search(pattern, text_lower)
        if match:
            try:
                amount_str = match.group(1).replace(",", "").replace(".", "")
                if "k" in pattern:
                    result["budget"] = int(float(amount_str) * 1000)
                elif "m" in pattern:
                    result["budget"] = int(float(amount_str) * 1000000)
                else:
                    result["budget"] = int(amount_str)
                break
            except:
                pass
    
    # 4. Neighborhood
    barrios = {
        "nu√±ez": "N√∫√±ez", "palermo": "Palermo", "belgrano": "Belgrano",
        "recoleta": "Recoleta", "san telmo": "San Telmo", "puerto madero": "Puerto Madero",
        "villa crespo": "Villa Crespo", "caballito": "Caballito", "flores": "Flores",
        "barracas": "Barracas", "boca": "La Boca", "tigre": "Tigre",
        "vicente lopez": "Vicente L√≥pez", "olivos": "Olivos", "martinez": "Mart√≠nez"
    }
    
    for barrio_key, barrio_nombre in barrios.items():
        if barrio_key in text_lower:
            result["neighborhood"] = barrio_nombre
            break
    
    # 5. Visit intent
    visit_keywords = ["visita", "ver", "conocer", "mostrar", "coordinar", "agendar"]
    result["visit_intent"] = any(keyword in text_lower for keyword in visit_keywords)
    
    # Si OpenAI est√° disponible, usar para refinar
    if client:
        try:
            extraction_prompt = """Extra√© informaci√≥n b√°sica de este mensaje inmobiliario en JSON:
- intent: "alquiler", "venta", o "consulta" (null si no est√° claro)
- rooms: n√∫mero de ambientes como entero (null si no se menciona)
- budget: presupuesto en pesos como entero (null si no se menciona)
- neighborhood: barrio mencionado (null si no se menciona)
- visit_intent: true si quiere ver/visitar propiedades

Convert√≠ montos: 150k=150000, 1.5M=1500000. Solo JSON:"""

            messages = [
                {"role": "system", "content": extraction_prompt},
                {"role": "user", "content": f"Texto: {text}"}
            ]
            resp = client.chat.completions.create(
                model=OPENAI_MODEL,
                messages=messages,
                response_format={"type": "json_object"},
            )
            ai_result = json.loads(resp.choices[0].message.content)
            
            # Combinar resultados: AI override si detecta algo que reglas no detectaron
            for key in ["intent", "rooms", "budget", "neighborhood", "visit_intent"]:
                if ai_result.get(key) and not result.get(key):
                    result[key] = ai_result[key]
                    
        except Exception as e:
            print(f"[AI][ERROR] {e}")
    
    return result



def parse_visit_datetime(text: str) -> dict:
    """
    Devuelve {"iso": "<ISO8601>"} o {"iso": null}
    Conf√≠a en OpenAI si hay API key; si no, vuelve null.
    """
    if not client:
        return {"iso": None}
    try:
        system_prompt = """Sos un parser de fechas/horarios en espa√±ol argentino para agendar visitas inmobiliarias.

OBJETIVO: Convertir expresiones de fecha/hora en espa√±ol a formato ISO8601 con zona horaria de Argentina (UTC-3).

FORMATO DE SALIDA: {"iso": "YYYY-MM-DDTHH:MM:SS-03:00"} o {"iso": null}

ACEPTO ESTAS EXPRESIONES:
- D√≠as de semana: "lunes", "martes", "mi√©rcoles", "jueves", "viernes", "s√°bado", "domingo"
- Fechas: "29/08", "15 de enero", "ma√±ana", "pasado ma√±ana", "hoy"
- Horarios: "15:00", "3 de la tarde", "18hs", "10am", "20:30"
- Combinadas: "viernes a las 15", "lunes 10am", "ma√±ana a las 18"

REGLAS:
- Si solo mencionan d√≠a sin hora, usar 10:00 AM por defecto
- Si solo mencionan hora sin d√≠a, usar el pr√≥ximo d√≠a h√°bil (lunes-viernes)
- "Ma√±ana" = siguiente d√≠a
- "Pasado ma√±ana" = d√≠a despu√©s de ma√±ana
- Horarios en formato 24hs: 15:00 = 3 PM
- Si hay ambig√ºedad o no se puede parsear, devolver {"iso": null}

EJEMPLOS:
"viernes a las 15" ‚Üí {"iso": "2024-01-12T15:00:00-03:00"} (asumiendo viernes pr√≥ximo)
"ma√±ana 18hs" ‚Üí {"iso": "2024-01-09T18:00:00-03:00"} (d√≠a siguiente)
"lunes por la ma√±ana" ‚Üí {"iso": "2024-01-15T10:00:00-03:00"} (lunes pr√≥ximo a las 10)
"no puedo" ‚Üí {"iso": null}

Devolv√© SOLO el JSON."""

        messages = [
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": text}
        ]
        resp = client.chat.completions.create(
            model=OPENAI_MODEL,
            messages=messages,
            response_format={"type": "json_object"},
        )
        import json
        data = json.loads(resp.choices[0].message.content)
        iso = data.get("iso")
        # Sanitizar: string no vac√≠a
        return {"iso": iso if isinstance(iso, str) and iso.strip() else None}
    except Exception as e:
        print(f"[AI][DATE][ERROR] {e}")
        return {"iso": None}


def format_datetime_for_user(iso_string: str) -> str:
    """
    Convierte una fecha ISO8601 a un formato legible para el usuario argentino.
    Ej: "2024-01-15T15:00:00-03:00" -> "lunes 15 de enero a las 15:00"
    """
    if not iso_string:
        return "fecha no especificada"
    
    try:
        # Parsear la fecha ISO
        dt = datetime.fromisoformat(iso_string.replace('Z', '+00:00'))
        
        # Nombres de d√≠as y meses en espa√±ol
        dias = ['lunes', 'martes', 'mi√©rcoles', 'jueves', 'viernes', 's√°bado', 'domingo']
        meses = [
            'enero', 'febrero', 'marzo', 'abril', 'mayo', 'junio',
            'julio', 'agosto', 'septiembre', 'octubre', 'noviembre', 'diciembre'
        ]
        
        # Obtener componentes
        dia_semana = dias[dt.weekday()]
        dia_mes = dt.day
        mes = meses[dt.month - 1]
        hora = dt.strftime("%H:%M")
        
        return f"{dia_semana} {dia_mes} de {mes} a las {hora}"
    
    except Exception as e:
        print(f"[FORMAT_DATE][ERROR] {e}")
        return "fecha no v√°lida"


def get_filtered_properties(lead_data: dict) -> list:
    """
    Obtiene propiedades filtradas seg√∫n los datos del lead para pasarle a la IA.
    """
    try:
        from services.dynamo import t_props
        from boto3.dynamodb.conditions import Attr
        
        # Construir filtros
        filter_expr = Attr("Status").eq("ACTIVE")
        
        # Filtrar por barrio si est√° disponible
        neighborhood = lead_data.get("Neighborhood")
        if neighborhood:
            filter_expr = filter_expr & Attr("Neighborhood").eq(neighborhood)
        
        # Filtrar por n√∫mero de ambientes si est√° disponible
        rooms = lead_data.get("Rooms")
        if rooms:
            filter_expr = filter_expr & Attr("Rooms").eq(rooms)
        
        # Filtrar por presupuesto si est√° disponible
        budget = lead_data.get("Budget")
        if budget:
            filter_expr = filter_expr & Attr("Price").lte(budget)
        
        resp = t_props.scan(FilterExpression=filter_expr, Limit=20)
        items = resp.get("Items", [])
        
        # Convertir a formato nativo y simplificar para la IA
        simplified_props = []
        for item in items:
            from models.schemas import dec_to_native
            prop = dec_to_native(item)
            simplified_props.append({
                "PropertyId": prop.get("PropertyId"),
                "Title": prop.get("Title"),
                "Neighborhood": prop.get("Neighborhood"),
                "Rooms": prop.get("Rooms"),
                "Price": prop.get("Price"),
                "URL": prop.get("URL")
            })
        
        return simplified_props
    except Exception as e:
        print(f"[GET_FILTERED_PROPS][ERROR] {e}")
        return []

def generate_agent_response(conversation_history: list, lead_data: dict, property_context: dict = None) -> str:
    """
    Genera la respuesta del agente usando exclusivamente el LLM con historial.
    No aplica reglas conversacionales hardcodeadas; toda la l√≥gica vive en el prompt.
    """
    # Llamar a OpenAI para generar la respuesta conversacional (si la API est√° disponible)
    if client:
        try:
            # Obtener propiedades filtradas para pasarle a la IA
            available_properties = get_filtered_properties(lead_data)
            print(f"[DEBUG] Propiedades filtradas encontradas: {len(available_properties)}")
            if available_properties:
                print(f"[DEBUG] Primera propiedad: {available_properties[0].get('Title', 'Sin t√≠tulo')}")
            
            # Construir contexto de propiedades disponibles
            property_info = ""
            if available_properties:
                property_info = f"\nüè† PROPIEDADES DISPONIBLES ({len(available_properties)}):\n"
                for i, prop in enumerate(available_properties[:10], 1):  # M√°ximo 10 para no saturar
                    title = prop.get("Title", "Sin t√≠tulo")
                    neighborhood = prop.get("Neighborhood", "")
                    rooms = prop.get("Rooms", "")
                    price = prop.get("Price", "")
                    
                    property_info += f"{i}. {title}"
                    if neighborhood:
                        property_info += f" - {neighborhood}"
                    if rooms:
                        property_info += f" - {rooms} amb"
                    if price:
                        try:
                            price_val = float(price)
                            if price_val >= 1000000:
                                price_str = f"${price_val/1000000:.1f}M"
                            elif price_val >= 1000:
                                price_str = f"${int(price_val/1000)}k"
                            else:
                                price_str = f"${int(price_val)}"
                            property_info += f" - {price_str}"
                        except:
                            pass
                    property_info += "\n"
                
                property_info += "\nUSA ESTA LISTA para identificar la propiedad exacta que busca el cliente. Si no encuentras coincidencia exacta, ped√≠ m√°s detalles."
            else:
                # No hay propiedades que coincidan con los filtros
                neighborhood = lead_data.get("Neighborhood")
                if neighborhood:
                    property_info = f"\n‚ùå LISTA VAC√çA: NO HAY PROPIEDADES en {neighborhood}."
                    property_info += f"\nüö® RESPUESTA OBLIGATORIA: 'No tengo propiedades disponibles en {neighborhood}. Me pod√©s dar m√°s detalles? Link, direcci√≥n exacta o c√≥digo?'"
                    property_info += f"\nüö´ PROHIBIDO: NO hagas preguntas de precalificaci√≥n como 'Es para vos o para alguien m√°s?' cuando la lista est√° vac√≠a."
                    property_info += f"\n‚úÖ SOLO ped√≠ m√°s detalles de la propiedad cuando no hay coincidencias."
                else:
                    property_info = "\nüìã NO HAY CRITERIOS ESPEC√çFICOS a√∫n. Necesitas m√°s informaci√≥n del cliente."

            # Preparar mensajes: prompt de sistema + historial completo (reciente)
            full_system_prompt = AGENT_SYSTEM_PROMPT + property_info
            print(f"[DEBUG] System prompt length: {len(full_system_prompt)}")
            print(f"[DEBUG] Property info: {property_info[:200]}...")
            messages = [{"role": "system", "content": full_system_prompt}]
            
            # Agregar recordatorio de reglas antes del historial
            if len(conversation_history) > 0:
                reminder_content = "RECORDATORIO: NUNCA uses signos de pregunta invertidos (¬ø) ni emojis. Escribe siempre sin ¬ø y sin emojis."
                if not available_properties and lead_data.get("Neighborhood"):
                    reminder_content += f" CR√çTICO: NO hay propiedades en {lead_data.get('Neighborhood')}. DEBES pedir m√°s detalles, NO contin√∫es con precalificaci√≥n."
                messages.append({
                    "role": "system", 
                    "content": reminder_content
                })
            
            # Limitar a √∫ltimos 20 mensajes para contexto suficiente
            for msg in conversation_history[-20:]:
                messages.append(msg)
            
            print(f"[DEBUG] Enviando {len(messages)} mensajes a OpenAI")
            print(f"[DEBUG] √öltimo mensaje del usuario: {conversation_history[-1].get('content', '') if conversation_history else 'N/A'}")

            response = client.chat.completions.create(
                model=OPENAI_MODEL,
                messages=messages,
                max_completion_tokens=1000
            )
            
            print(f"[DEBUG] Respuesta recibida de OpenAI: '{response.choices[0].message.content}'")
            
            result = response.choices[0].message.content
            if result is None:
                print("[AI][ERROR] API retorn√≥ contenido None")
                return None
            
            result = result.strip()
            if not result:
                print("[AI][ERROR] API retorn√≥ contenido vac√≠o")
                return None
            
            # Separar m√∫ltiples preguntas en mensajes individuales
            if "?" in result and result.count("?") > 1:
                # Dividir por preguntas y limpiar
                parts = result.split("?")
                messages = []
                for part in parts:
                    part = part.strip()
                    if part and not part.endswith("."):
                        messages.append(part + "?")
                    elif part:
                        messages.append(part)
                
                # Si hay m√∫ltiples mensajes, devolver solo el primero
                # El webhook se encargar√° de enviar los siguientes
                if len(messages) > 1:
                    # Guardar los mensajes restantes en el lead para enviarlos despu√©s
                    # Devolver el primer mensaje como string normal
                    return messages[0]
            
            return result
        except Exception as e:
            print(f"[AGENT_RESPONSE][ERROR] {e}")
            return None

    # Si no hay cliente disponible, no responder nada
    return None


